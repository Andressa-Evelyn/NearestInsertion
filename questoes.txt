*****************************************************************************************************
T290 - Resolução de Problemas com Grafos
Orientador: Prof. Me Ricardo Carubbi
*****************************************************************************************************

Trabalho: Problema do Caixeiro Viajante

Informe abaixo o(s) nome(s):
- Aluno(a) 1: Andressa Evelyn Lima de Luna - 2320483
- Aluno(a) 2: ______________________________

Q1. Explique como você implementou a heurística de inserção pelo vizinho mais próximo.
Comente também como você atualiza as ligações da lista encadeada circular após inserir o novo ponto.

Resposta:

Implementei a heurística do vizinho mais próximo percorrendo todos os pontos já inseridos na lista encadeada circular e escolhendo aquele cuja distância euclidiana até o novo ponto é a menor.
A cada nova inserção, percorro a lista começando do nó inicial (start), calculo a distância entre o ponto p e cada ponto do tour com point.distanceTo(p), e mantenho o nó mais próximo.
Depois, insiro o novo nó logo após esse vizinho mais próximo, ajustando os ponteiros next de forma a manter a circularidade.
Para atualizar as ligações, crio um novo nó newNode e faço:
newNode.next = nearest.next;
nearest.next = newNode;
Se for o primeiro ponto, ele aponta para ele mesmo (newNode.next = newNode), formando um ciclo unitário.
Assim, a cada inserção, o tour se mantém circular e totalmente conectado.

Q2. Explique por que é melhor usar uma lista encadeada circular em vez de um vetor.
Considere a complexidade das operações de inserção e remoção de pontos.

Resposta:

A lista encadeada circular é melhor porque permite inserir e remover pontos em tempo constante O(1), apenas ajustando os ponteiros, sem precisar deslocar elementos como acontece em vetores.
Em um vetor, inserir um novo ponto no meio exige mover todos os elementos à direita, resultando em custo O(n).
Na lista encadeada circular, como cada nó contém apenas uma referência para o próximo, a atualização das ligações é simples e eficiente — ideal para o TSP, onde inserções são frequentes durante a construção da rota.

Q3. Preencha os comprimentos calculados pela heurística do vizinho mais próximo.

| Arquivo de dados | Vizinho mais próximo |
| ---------------- | -------------------- |
| tsp10.txt        |  1566.1363051360363  |
| tsp100.txt       |   7389.929676351667  |
| tsp1000.txt      |  27868.710634854797  |
| usa13509.txt     |  77449.97941714071   |

Q4. Realize a análise de tempo abaixo:

- Estime o tempo de execução (em segundos) da heurística.
- Execute a heurística para \(n = 1000\) e dobre \(n\) repetidamente até que o tempo de execução ultrapasse 60 segundos.
- Utilize o **TSPTimer** com a opção **-Xint** para desativar otimizações do compilador.

             NAIVE                   KDTREE
| 1000   | 0.016 segundos    |     0.016 segundos    |
| 2000   | 0.062 segundos    |     0.031 segundos    |
| 4000   | 0.26 segundos     |     0.11 segundos     |
| 8000   | 1.068 segundos    |     0.421 segundos    |
| 16000  | 4.361 segundos    |     1.685 segundos    |
| 32000  | 18.692 segundos   |     7.18 segundos     |
| 64000  |   +1min           |     31.033 segundos   |
| 128000 |   +1min           |       +1min           |
| 256000 |   +1min           |       +1min           |
| 512000 |   +1min           |       +1min           |
| 1024000|   +1min           |       +1min           |
